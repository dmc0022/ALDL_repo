// hub75_phase2_gradient_ref.v
// Phase 2 reference: Full-screen RGB gradient + PWM brightness
// - 3-bit per color intensity (0..7) using bit-plane PWM (3 planes)
// - Global brightness scaling from bright[2:0] (8 levels)
// - Same HUB75 scan FSM: SHIFT -> LATCH -> SHOW

module hub75_phase2_gradient (
    input  wire       clk,
    input  wire       reset_n,
    input  wire [2:0] bright,      // SW[4:2] recommended (0..7)

    output reg        r1,
    output reg        g1,
    output reg        b1,
    output reg        r2,
    output reg        g2,
    output reg        b2,

    output reg  [3:0] row_addr,
    output reg        clk_out,
    output reg        lat,
    output reg        oe
);

    // Panel geometry
    localparam integer WIDTH          = 32;
    localparam integer ROWS_PER_GROUP = 16;   // 1/16 scan
    localparam integer PLANES         = 3;    // 3-bit PWM: planes 0..2

    // Timing (50 MHz)
    // Base show ticks for plane 0 (LSB). Planes are weighted 1,2,4.
    // Global brightness scales these show times (bright+1)/8.
    localparam integer BASE_SHOW_TICKS = 800;

    // OE polarity (OE=0 enables output on most HUB75 panels)
    localparam OE_ON  = 1'b0;
    localparam OE_OFF = 1'b1;

    // FSM states
    localparam S_SHIFT = 2'd0;
    localparam S_LATCH = 2'd1;
    localparam S_SHOW  = 2'd2;

    reg [1:0] state;

    reg [5:0] col_idx;       // 0..31
    reg [3:0] row_idx;       // 0..15
    reg       shift_phase;   // 0=setup data, 1=pulse clk
    reg [15:0] show_cnt;

    reg [1:0] plane;         // 0..2 (bit-plane index)
    reg [15:0] show_limit;   // computed duration for current plane

    // ------------------------------------------------------------
    // Coordinate mapping for current scan row-pair
    // ------------------------------------------------------------
    wire [5:0] x     = col_idx;              // 0..31
    wire [5:0] y_top = {2'b00, row_idx};     // 0..15
    wire [5:0] y_bot = {2'b01, row_idx};     // 16..31

    // ------------------------------------------------------------
    // 3-bit gradient levels (0..7)
    // R increases left->right, G increases top->bottom, B diagonal
    // ------------------------------------------------------------
    wire [2:0] r_lvl = x[4:2];                 // 0..7 across width
    wire [2:0] g_top_lvl = y_top[4:2];         // 0..3 (top half)
    wire [2:0] g_bot_lvl = y_bot[4:2];         // 4..7 (bottom half)

    wire [6:0] sum_top = x + y_top;
    wire [6:0] sum_bot = x + y_bot;
    wire [2:0] b_top_lvl = sum_top[4:2];
    wire [2:0] b_bot_lvl = sum_bot[4:2];

    // Extract current plane bit (0/1) for each channel
    wire r_bit      = ((r_lvl      >> plane) & 3'b001);
    wire g_top_bit  = ((g_top_lvl  >> plane) & 3'b001);
    wire b_top_bit  = ((b_top_lvl  >> plane) & 3'b001);
    wire g_bot_bit  = ((g_bot_lvl  >> plane) & 3'b001);
    wire b_bot_bit  = ((b_bot_lvl  >> plane) & 3'b001);

    // ------------------------------------------------------------
    // Helper: compute show_limit for current plane and brightness
    // show_limit = (BASE_SHOW_TICKS * 2^plane) * (bright+1) / 8
    // ------------------------------------------------------------
    reg [31:0] scaled;
    always @(*) begin
        scaled = (BASE_SHOW_TICKS << plane) * (bright + 3'd1);
    end

    // ------------------------------------------------------------
    // Sequential logic
    // ------------------------------------------------------------
    always @(posedge clk or negedge reset_n) begin
        if (!reset_n) begin
            // outputs
            r1 <= 0; g1 <= 0; b1 <= 0;
            r2 <= 0; g2 <= 0; b2 <= 0;
            row_addr <= 0;
            clk_out <= 0;
            lat <= 0;
            oe  <= OE_OFF;

            // fsm
            state <= S_SHIFT;
            col_idx <= 0;
            row_idx <= 0;
            shift_phase <= 0;
            show_cnt <= 0;

            // pwm
            plane <= 0;
            show_limit <= 16'd100;

        end else begin
            lat <= 1'b0;          // default
            row_addr <= row_idx;  // drive row address continuously

            case (state)

                // -----------------------------
                // SHIFT: output data + pulse CLK (32 columns)
                // -----------------------------
                S_SHIFT: begin
                    oe <= OE_OFF;      // blank while shifting
                    clk_out <= 1'b0;   // default low

                    if (shift_phase == 1'b0) begin
                        // Setup pixel data for this column (current plane)
                        r1 <= r_bit;
                        g1 <= g_top_bit;
                        b1 <= b_top_bit;

                        r2 <= r_bit;
                        g2 <= g_bot_bit;
                        b2 <= b_bot_bit;

                        shift_phase <= 1'b1;
                    end else begin
                        // Pulse panel clock (rising edge shifts data)
                        clk_out <= 1'b1;
                        shift_phase <= 1'b0;

                        if (col_idx == WIDTH-1) begin
                            col_idx <= 0;
                            state <= S_LATCH;
                        end else begin
                            col_idx <= col_idx + 1'b1;
                        end
                    end
                end

                // -----------------------------
                // LATCH: commit row data
                // -----------------------------
                S_LATCH: begin
                    oe <= OE_OFF;
                    clk_out <= 1'b0;
                    lat <= 1'b1;

                    show_cnt <= 0;
                    show_limit <= (scaled >> 3);  // divide by 8 for brightness scaling
                    if ((scaled >> 3) == 0)
                        show_limit <= 16'd1;      // safety clamp

                    state <= S_SHOW;
                end

                // -----------------------------
                // SHOW: enable LEDs for weighted plane time
                // -----------------------------
                S_SHOW: begin
                    clk_out <= 1'b0;
                    oe <= OE_ON;

                    if (show_cnt == (show_limit - 1)) begin
                        oe <= OE_OFF;
                        show_cnt <= 0;

                        // Next plane or next row
                        if (plane == (PLANES-1)) begin
                            plane <= 0;

                            if (row_idx == ROWS_PER_GROUP-1)
                                row_idx <= 0;
                            else
                                row_idx <= row_idx + 1'b1;

                        end else begin
                            plane <= plane + 1'b1;
                        end

                        state <= S_SHIFT;
                    end else begin
                        show_cnt <= show_cnt + 1'b1;
                    end
                end

                default: state <= S_SHIFT;
            endcase
        end
    end

endmodule
